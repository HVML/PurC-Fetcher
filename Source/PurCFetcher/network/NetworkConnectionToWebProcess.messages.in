# Copyright (C) 2012-2019 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

messages -> NetworkConnectionToWebProcess LegacyReceiver {

    ScheduleResourceLoad(PurcFetcher::NetworkResourceLoadParameters resourceLoadParameters)
    PerformSynchronousLoad(PurcFetcher::NetworkResourceLoadParameters resourceLoadParameters) -> (PurcFetcher::ResourceError error, PurcFetcher::ResourceResponse response, Vector<char> data) Synchronous
    TestProcessIncomingSyncMessagesWhenWaitingForSyncReply(PurcFetcher::WebPageProxyIdentifier pageID) -> (bool handled) Synchronous
    LoadPing(PurcFetcher::NetworkResourceLoadParameters resourceLoadParameters)
    RemoveLoadIdentifier(uint64_t resourceLoadIdentifier)
    PageLoadCompleted(PurcFetcher::PageIdentifier webPageID)
    BrowsingContextRemoved(PurcFetcher::WebPageProxyIdentifier webPageProxyID, PurcFetcher::PageIdentifier webPageID, PurcFetcher::FrameIdentifier webFrameID)
    PrefetchDNS(String hostname)
    PreconnectTo(Optional<uint64_t> preconnectionIdentifier, PurcFetcher::NetworkResourceLoadParameters loadParameters);

    StartDownload(PurcFetcher::DownloadID downloadID, PurcFetcher::ResourceRequest request, enum:bool Optional<PurcFetcher::NavigatingToAppBoundDomain> isNavigatingToAppBoundDomain, String suggestedName)
    ConvertMainResourceLoadToDownload(uint64_t mainResourceLoadIdentifier, PurcFetcher::DownloadID downloadID, PurcFetcher::ResourceRequest request, PurcFetcher::ResourceResponse response, enum:bool Optional<PurcFetcher::NavigatingToAppBoundDomain> isNavigatingToAppBoundDomain)

    CookiesForDOM(URL firstParty, struct PurcFetcher::SameSiteInfo sameSiteInfo, URL url, PurcFetcher::FrameIdentifier frameID, PurcFetcher::PageIdentifier pageID, enum:bool PurcFetcher::IncludeSecureCookies includeSecureCookies, enum:bool PurcFetcher::ShouldAskITP shouldAskITP, enum:bool PurcFetcher::ShouldRelaxThirdPartyCookieBlocking shouldRelaxThirdPartyCookieBlocking) -> (String cookieString, bool didAccessSecureCookies) Synchronous
    SetCookiesFromDOM(URL firstParty, struct PurcFetcher::SameSiteInfo sameSiteInfo, URL url, PurcFetcher::FrameIdentifier frameID, PurcFetcher::PageIdentifier pageID, enum:bool PurcFetcher::ShouldAskITP shouldAskITP, String cookieString, enum:bool PurcFetcher::ShouldRelaxThirdPartyCookieBlocking shouldRelaxThirdPartyCookieBlocking)
    CookieRequestHeaderFieldValue(URL firstParty, struct PurcFetcher::SameSiteInfo sameSiteInfo, URL url, Optional<PurcFetcher::FrameIdentifier> frameID, Optional<PurcFetcher::PageIdentifier> pageID, enum:bool PurcFetcher::IncludeSecureCookies includeSecureCookies, enum:bool PurcFetcher::ShouldAskITP shouldAskITP, enum:bool PurcFetcher::ShouldRelaxThirdPartyCookieBlocking shouldRelaxThirdPartyCookieBlocking) -> (String cookieString, bool didAccessSecureCookies) Synchronous
    GetRawCookies(URL firstParty, struct PurcFetcher::SameSiteInfo sameSiteInfo, URL url, Optional<PurcFetcher::FrameIdentifier> frameID, Optional<PurcFetcher::PageIdentifier> pageID, enum:bool PurcFetcher::ShouldAskITP shouldAskITP, enum:bool PurcFetcher::ShouldRelaxThirdPartyCookieBlocking shouldRelaxThirdPartyCookieBlocking) -> (Vector<PurcFetcher::Cookie> cookies) Synchronous
    SetRawCookie(struct PurcFetcher::Cookie cookie)
    DeleteCookie(URL url, String cookieName)
    DomCookiesForHost(String host, bool subscribeToCookieChangeNotifications) -> (Vector<PurcFetcher::Cookie> cookies) Synchronous
#if HAVE(COOKIE_CHANGE_LISTENER_API)
    UnsubscribeFromCookieChangeNotifications(HashSet<String> hosts)
#endif

    RegisterFileBlobURL(URL url, String path, PurcFetcher::SandboxExtension::Handle extensionHandle, String contentType)
    RegisterBlobURL(URL url, Vector<PurcFetcher::BlobPart> blobParts, String contentType)
    RegisterBlobURLFromURL(URL url, URL srcURL)
    RegisterBlobURLOptionallyFileBacked(URL url, URL srcURL, String fileBackedPath, String contentType)
    RegisterBlobURLForSlice(URL url, URL srcURL, int64_t start, int64_t end)
    UnregisterBlobURL(URL url)
    BlobSize(URL url) -> (uint64_t resultSize) Synchronous
    WriteBlobsToTemporaryFiles(Vector<String> blobURLs) -> (Vector<String> fileNames) Async

    SetCaptureExtraNetworkLoadMetricsEnabled(bool enabled)

    CreateSocketStream(URL url, String cachePartition, PurcFetcher::WebSocketIdentifier identifier)
    CreateSocketChannel(PurcFetcher::ResourceRequest request, String protocol, PurcFetcher::WebSocketIdentifier identifier)

#if ENABLE(RESOURCE_LOAD_STATISTICS)
    RemoveStorageAccessForFrame(PurcFetcher::FrameIdentifier frameID, PurcFetcher::PageIdentifier pageID);
    ClearPageSpecificDataForResourceLoadStatistics(PurcFetcher::PageIdentifier pageID);
    LogUserInteraction(PurcFetcher::RegistrableDomain domain)
    ResourceLoadStatisticsUpdated(Vector<PurcFetcher::ResourceLoadStatistics> statistics)
    HasStorageAccess(PurcFetcher::RegistrableDomain subFrameDomain, PurcFetcher::RegistrableDomain topFrameDomain, PurcFetcher::FrameIdentifier frameID, PurcFetcher::PageIdentifier pageID) -> (bool hasStorageAccess) Async
    RequestStorageAccess(PurcFetcher::RegistrableDomain subFrameDomain, PurcFetcher::RegistrableDomain topFrameDomain, PurcFetcher::FrameIdentifier frameID, PurcFetcher::PageIdentifier webPageID, PurcFetcher::WebPageProxyIdentifier webPageProxyID, enum:bool PurcFetcher::StorageAccessScope scope) -> (struct PurcFetcher::RequestStorageAccessResult result) Async
    RequestStorageAccessUnderOpener(PurcFetcher::RegistrableDomain domainInNeedOfStorageAccess, PurcFetcher::PageIdentifier openerPageID, PurcFetcher::RegistrableDomain openerDomain)
#endif

    AddOriginAccessWhitelistEntry(String sourceOrigin, String destinationProtocol, String destinationHost, bool allowDestinationSubdomains);
    RemoveOriginAccessWhitelistEntry(String sourceOrigin, String destinationProtocol, String destinationHost, bool allowDestinationSubdomains);
    ResetOriginAccessWhitelists();

    GetNetworkLoadInformationResponse(uint64_t resourceLoadIdentifier) -> (PurcFetcher::ResourceResponse response) Synchronous
    GetNetworkLoadIntermediateInformation(uint64_t resourceLoadIdentifier) -> (Vector<PurcFetcher::NetworkTransactionInformation> transactions) Synchronous
    TakeNetworkLoadInformationMetrics(uint64_t resourceLoadIdentifier) -> (PurcFetcher::NetworkLoadMetrics networkMetrics) Synchronous

#if ENABLE(SERVICE_WORKER)
    EstablishSWContextConnection(PurcFetcher::RegistrableDomain domain) -> () Async
    CloseSWContextConnection()
#endif

    UpdateQuotaBasedOnSpaceUsageForTesting(struct PurcFetcher::ClientOrigin origin)
    CreateNewMessagePortChannel(struct PurcFetcher::MessagePortIdentifier port1, struct PurcFetcher::MessagePortIdentifier port2)
    EntangleLocalPortInThisProcessToRemote(struct PurcFetcher::MessagePortIdentifier local, struct PurcFetcher::MessagePortIdentifier remote)
    MessagePortDisentangled(struct PurcFetcher::MessagePortIdentifier local)
    MessagePortClosed(struct PurcFetcher::MessagePortIdentifier local)
    TakeAllMessagesForPort(struct PurcFetcher::MessagePortIdentifier port) -> (Vector<PurcFetcher::MessageWithMessagePorts> messages, uint64_t messageBatchIdentifier) Async
    PostMessageToRemote(struct PurcFetcher::MessageWithMessagePorts message, struct PurcFetcher::MessagePortIdentifier remote)
    CheckRemotePortForActivity(struct PurcFetcher::MessagePortIdentifier port) -> (bool hasActivity) Async
    DidDeliverMessagePortMessages(uint64_t messageBatchIdentifier)
    RegisterURLSchemesAsCORSEnabled(Vector<String> schemes);
}
